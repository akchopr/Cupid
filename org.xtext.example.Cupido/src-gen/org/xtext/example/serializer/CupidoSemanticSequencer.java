/*
 * generated by Xtext
 */
package org.xtext.example.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.cupido.AExpr;
import org.xtext.example.cupido.Commitment;
import org.xtext.example.cupido.CupidoPackage;
import org.xtext.example.cupido.EExpr;
import org.xtext.example.cupido.Event;
import org.xtext.example.cupido.EventRelation;
import org.xtext.example.cupido.Expr;
import org.xtext.example.cupido.Interval;
import org.xtext.example.cupido.OExpr;
import org.xtext.example.cupido.Param;
import org.xtext.example.cupido.Schemata;
import org.xtext.example.cupido.TimeStamp;
import org.xtext.example.cupido.WExpr;
import org.xtext.example.services.CupidoGrammarAccess;

@SuppressWarnings("all")
public class CupidoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CupidoGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == CupidoPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case CupidoPackage.AEXPR:
				sequence_AExpr(context, (AExpr) semanticObject); 
				return; 
			case CupidoPackage.COMMITMENT:
				sequence_Commitment(context, (Commitment) semanticObject); 
				return; 
			case CupidoPackage.EEXPR:
				sequence_EExpr(context, (EExpr) semanticObject); 
				return; 
			case CupidoPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case CupidoPackage.EVENT_RELATION:
				sequence_EventRelation(context, (EventRelation) semanticObject); 
				return; 
			case CupidoPackage.EXPR:
				sequence_BExpr(context, (Expr) semanticObject); 
				return; 
			case CupidoPackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case CupidoPackage.OEXPR:
				sequence_OExpr(context, (OExpr) semanticObject); 
				return; 
			case CupidoPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case CupidoPackage.SCHEMATA:
				if(context == grammarAccess.getCupidoRule()) {
					sequence_Cupido_Schemata(context, (Schemata) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getSchemataRule()) {
					sequence_Schemata(context, (Schemata) semanticObject); 
					return; 
				}
				else break;
			case CupidoPackage.TIME_STAMP:
				sequence_TimeStamp(context, (TimeStamp) semanticObject); 
				return; 
			case CupidoPackage.WEXPR:
				sequence_WExpr(context, (WExpr) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (left=AExpr_AExpr_1_0 right=WExpr)
	 */
	protected void sequence_AExpr(EObject context, AExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     interval=Interval
	 */
	protected void sequence_BExpr(EObject context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         label=ID 
	 *         debtor=ID 
	 *         creditor=ID 
	 *         trigger=EExpr 
	 *         antecedent=EExpr? 
	 *         consequent=EExpr
	 *     )
	 */
	protected void sequence_Commitment(EObject context, Commitment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (schemata+=EventRelation+ commitments+=Commitment*)
	 */
	protected void sequence_Cupido_Schemata(EObject context, Schemata semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=EExpr_EExpr_1_0 right=OExpr)
	 */
	protected void sequence_EExpr(EObject context, EExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         event=Event 
	 *         params+=Param 
	 *         params+=Param* 
	 *         keyParams+=Param 
	 *         keyParams+=Param* 
	 *         timeParam=Param
	 *     )
	 */
	protected void sequence_EventRelation(EObject context, EventRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID | ((lifeState=CREATED | lifeState=DETACHED | lifeState=DISCHARGED | lifeState=EXPIRED | lifeState=VIOLATED) label=ID))
	 */
	protected void sequence_Event(EObject context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (event=Event | (event=Event left=TimeStamp right=TimeStamp) | (event=Event right=TimeStamp) | (event=Event left=TimeStamp) | event=Event)
	 */
	protected void sequence_Interval(EObject context, Interval semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=OExpr_OExpr_1_0 right=AExpr)
	 */
	protected void sequence_OExpr(EObject context, OExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Param(EObject context, Param semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, CupidoPackage.Literals.PARAM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CupidoPackage.Literals.PARAM__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParamAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     schemata+=EventRelation+
	 */
	protected void sequence_Schemata(EObject context, Schemata semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (val=INT | (eventReference=ID shift=INT?))
	 */
	protected void sequence_TimeStamp(EObject context, TimeStamp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=WExpr_WExpr_1_0 right=STRING)
	 */
	protected void sequence_WExpr(EObject context, WExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
