/*
 * generated by Xtext
 */
package org.xtext.example.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.xtext.example.cupido.Commitment
import org.xtext.example.cupido.EventRelation

/**
 * Generates code from your model files on save.
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class CupidoGenerator implements IGenerator {

  override void doGenerate(Resource resource, IFileSystemAccess fsa) {
  fsa.generateFile('schema.sql', resource.generateRelations)
  fsa.generateFile('commitments.algebra', resource.generateCommitments)
  }
  
  def CharSequence generateCommitments(Resource resource) {
  	var result = ""
  	for (comm: resource.allContents.toIterable.filter(Commitment)) {
	  result += "==========\n"
  	  result += '''For «comm.label», we obtain these queries:'''
	  result += comm.compileAll
	  result += "\n\n"
	}
	return result
  }
 
  def CharSequence generateRelations(Resource resource) {
  	var result = ""
  	for (sch: resource.allContents.toIterable.filter(EventRelation)) {
  		result += sch.generateRelation
  		result += "\n"
  	}
  	return result
  }  

  def CharSequence generateRelation (EventRelation s) {
	Parser.getParser().storeEventRelation(s)
    return Parser.getParser().toSQL(s)
  }

  def CharSequence compileAll(Commitment c) {
  	val RelationalExpr cDetached = Parser.getParser().compileDetached(c) 
    return // RA asks for a terminating semicolon for each query
    //  "CREATED: " + c.compileCreated + ";\n" +
      "\nDETACHED: " + cDetached.toRelationalAlgebra + ";" //+
     // "EXPIRED: " + c.compileExpired + ";\n" +
      //"VIOLATED: " + c.compileViolated + ";\n" +
      //"DISCHARGED: " + c.compileDischarged
  }

}
